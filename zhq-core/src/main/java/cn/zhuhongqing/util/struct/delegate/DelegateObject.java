package cn.zhuhongqing.util.struct.delegate;

/**
 * A map entry which forwards all its method calls to another map entry. Subclasses should override
 * one or more methods to modify the behavior of the backing map entry as desired per the <a
 * href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>.
 *
 * <p><b>Warning:</b> The methods of {@code ForwardingMapEntry} forward <i>indiscriminately</i> to
 * the methods of the delegate. For example, overriding {@link #getValue} alone <i>will not</i>
 * change the behavior of {@link #equals}, which can lead to unexpected behavior. In this case, you
 * should override {@code equals} as well, either providing your own implementation, or delegating
 * to the provided {@code standardEquals} method.
 *
 * <p>Each of the {@code standard} methods, where appropriate, use {@link Objects#equal} to test
 * equality for both keys and values. This may not be the desired behavior for map implementations
 * that use non-standard notions of key equality, such as the entry of a {@code SortedMap} whose
 * comparator is not consistent with {@code equals}.
 *
 * <p>The {@code standard} methods are not guaranteed to be thread-safe, even when all of the
 * methods that they depend on are thread-safe.
 *
 * @author Mike Bostock
 * @author Louis Wasserman
 */

public abstract class DelegateObject {

	/**
	 * Returns the backing delegate instance that methods are forwarded to. 
	 * Abstract subclasses generally override this method with an abstract method that has a more specific return type, 
	 * such as {@link ForwardingSet#delegate}. 
	 * Concrete subclasses override this method to supply the instance being decorated.
	 */
	protected abstract Object delegate();

	/**
	 * Returns the string representation generated by the delegate's {@code toString} method.
	 */
	@Override
	public String toString() {
		return delegate().toString();
	}

	/* No equals or hashCode. See class comments for details. */

}
